// 4.11.1 SAM 변환
// 코틀린에서는 추상 메이드 하나를 인수로 사용할 때는 함수를 인수로 전달하면 편하다.
// 자바로 작성된 메서드가 하나인 인터페이스를 구현할 때는 대신 함수를 작성할 수 있다.
// 이를 SAM(Single Abstract Method) 변환이라고 한다.
// SAM 변환의 예를 안드로이드로 들어보면 안드로이드에서는 버튼의 클릭 이벤트를 구현할 때
// onClick() 추상 메서드만 가지는 View.OnClickListener 인터페이스를 구현한다.

// 다음 코드는 안드로이드에서 버튼에 클릭 이벤트 리스너를 구현하는 코드를 일반적인 익명 클래스를
// 작성하듯 작성한 코드이다. 여기서 View.OnClickListener 인터페이스에는 onCLick()
// 추상 메서드가 하나 있기 때문에 onClick() 메서드를 오버라이드하고 있습니다.

button.setOnClickListener(object : View.OnClickListener{
    override fun onClick(v: View?){
        // 클릭시 처리
    }
})

// 구현하는 인터페이스에 구현해야 할 메서드가 하나뿐일 때는 이를 람다식으로 변경할 수 있다.
// 다음 코드는 람다식으로 변경되어 코드가 줄었지만 괄호도 중첩되어 있고 기호도 많고 뭔가 코드가
// 복잡해보인다

button.setOnClickListener({ v: View? ->
    {
    // 클릭 시 처리
    }
})

// 메서드 호출 시 맨 뒤에 전달되는 인수가 람다식인 경우에는 람다식을 괄호 밖으로 뺄수 있다.
// 위 코드는 하나의 인수만 있고 람다식이 전달되었기 때문에 마지막 인수라고 볼수 있다.

button.setOnClickListener { v: View? ->
    // 클릭 시 처리
    }

// 람다가 어떤 메서드의 유일한 인수인 경우에는 메서드의 괄호가 생략할 수 있다.

button.setOnClickListener { v ->
    // 클릭 시 처리
}

// 만약 클릭 시 처리에 어떤 코드를 작성했는데 v 인수를 사용하지 않는다면 v라는 이름은 _ 기호로
// 대치할 수 있다. 인수가 많은 경우에 꼭 사용하는 인수 이외에는 _ 기호로 변경하여
// 애초에 잘못 사용하는 것을 방지할 수도 있다.
// 이러한 방식은 다른 함수형 언어에서도 적용되는 함수형 언어의 특징 중 하나이다.

button.setOnClickListener { _ ->
    // 클릭 시 처리
}

// 그리고 람다식에서 인수가 하나인 경우에는 이를 아예 생략하고 담다 블록 내에서 인수를
// it로 접근할 수 있다.
// 다음 코드에서 it는 View? 타입의 v인수를 기리긴다.

button.setOnClickListener {
    it.visibility = View.GONE
}

// 위 7가지 형태는 모두 같은 결과를 나타내지만 마지막 코드가 가장 읽기 쉽다.
// 중요한것은 SAM 변환은 자바에서 작성한 인터페이스일 때만 동작한다는 것이다.
// 코틀린에서는 인터페이스 대신에 함수를 사용하는 것이 좋다.
